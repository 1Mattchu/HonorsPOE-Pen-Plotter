#pragma config(Sensor, dgtl1,  LEDpwr,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl2,  LEDactive,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  LEDstandby,     sensorLEDtoVCC)
#pragma config(Sensor, dgtl4,  LEDdebug,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl5,  LimitX,         sensorTouch)
#pragma config(Sensor, dgtl6,  LimitY,         sensorTouch)
#pragma config(Sensor, dgtl7,  ButtX,          sensorNone)
#pragma config(Sensor, dgtl8,  ButtY,          sensorNone)
#pragma config(Sensor, dgtl9,  ButtPen0_o,     sensorNone)
#pragma config(Sensor, dgtl10, ButtNeg,        sensorNone)
#pragma config(Motor,  port2,           PenControl,    tmotorServoStandard, openLoop)
#pragma config(Motor,  port3,           MotorX,        tmotorVex393_MC29, openLoop, reversed)	//These are on 3to2 pin motor adapters
#pragma config(Motor,  port4,           MotorY,        tmotorVex393_MC29, openLoop)				//These are on 3to2 pin motor adapters
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//This is getting insane
//Additional files kept in directory (To remain somewhat consistaint)
//#include "14SegmentDisplayFont.c"
//ENDOF additional files

//THE MOST IMPORTAINT ONE OF ALL
int cheese=0;	//Used for debuging... or is it?  Haha just kidding...							unless?


//the final Speed of which to control XY motors
int XrealSpeed = 0;//EDIT its because startMotor does not accept Floats			//For some reason I have to make the math outside of the start motor movements for negetives
int YrealSpeed = 0;

float xypoints[2];	//makeing an array for the XY points cuz im dumb		THANK YOU MR.MAZZIE THIS WAS AN INT BEFORE!!!
float Xdistance = 0;	//current distance of X
float Ydistance = 0;	//current distance of Y
const int Xmax = 200;	//MAX distance X axis can be before error	CHANGE LATER
const int Ymax = 200;	//MAX distance Y axis can be before error	CHAGNE LATER


//set motor speeds, fast, standard, slow
const int fastMotorSpeed = 127;
//const int standardMotorSpeed = 40;
const int slowMotorSpeed = 30;

//Speed% to calculate for the motors rotation speed.  Multiplied by slowmmspeed.  Range from -1 to 1
float Xspeed = 0;
float Yspeed = 0;

const int standardmmTime = 2000; //milliseconds it takes to move 1mm at standard 		CHANGE LATER
const int slowmmTime = 100; //milliseconds it takes to move 1mm at slow 						CHANGE LATER
float slowtotaltime = 0;	//the total time it will take to move
	//variables for the pen control
const int penRaise = -100;	//the number to send to the servo motor to raise the pen up in the air - accepted values = -127 to 127
const int penLower = 60;	//the number to send to the servo motor to lower the pen on paper - accepted values = -127 to 127
/*bool penUPorDOWN = true;	//a boolean statement, if it is set to TRUE or 1, it will raise the pen up, if it is FALSE or 0 it will lower.*/


//checks to see if x or y points given from line[] are negative.  They are divided by an abs. value of itself. i.e. 2/2=1 ... -2/|-2|=-1
int Xneg = 1;
int Yneg = 1;






void pen(bool penUPorDOWN){//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//Will raise or lower the pen,if () has TRUE or 1 it will raise, if it is FALSE or 0 it will lower
	if(penUPorDOWN == true){
		motor[PenControl] = penRaise;
	}else{motor[PenControl] = penLower;}
	wait1Msec(500);	//delay to make sure that the servo makes it to position
}




void home(){//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//Homes the plotter to 0,0
	turnLEDOff(LEDstandby);
	turnLEDOn(LEDactive);//Turns led into active mode
	pen(true);//Raises the pen

	//--Y Homing--
		while(SensorValue(LimitY) == 0){
		startMotor(MotorY,-1*fastMotorSpeed);//Move motor backwards until limit switch is pressed (inaccurate)
		}
	clearTimer(T1);
	while(time1[T1] < slowmmTime*12){startMotor(MotorY,slowMotorSpeed);}	stopMotor(MotorX);//Move motor forwards ~12mm~
	while(SensorValue(LimitY) == 0){
		startMotor(MotorY,-1*slowMotorSpeed);//Move motor backwards until limit switch is pressed (slow and acctuate)
		}
	stopMotor(MotorY);
	Ydistance = 0;//set distance to 0
	//--Y Homing--

	//--X Homing--
	while(SensorValue(LimitX) == 0){
		startMotor(MotorX,-1*fastMotorSpeed);//Move motor backwards until limit switch is pressed (inaccurate) used to quickly get to location
		}
	clearTimer(T1);
	while(time1[T1] < slowmmTime*12){startMotor(MotorX,slowMotorSpeed);}
		stopMotor(MotorX);//Move motor forwards ~12mm~
	while(SensorValue(LimitX) == 0){
		startMotor(MotorX,-1*slowMotorSpeed);//Move motor backwards until limit switch is pressed (slow and acctuate)final home
		}
	stopMotor(MotorX);
	Xdistance = 0;//set distance to 0
	//--X Homing--


}




void startup(){//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//what code is first started by the plotter
	turnLEDOn(LEDpwr);
	turnLEDOn(LEDstandby);
	pen(true);
	home();

}




bool outofbounds(){//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 if((Xdistance+xypoints[0])<0 || (Ydistance+xypoints[1])<0){	//Does this command request go out of boundary?
  	for (int i = 0; i <= 5; i++) {
	 		turnLEDOn(LEDdebug);
	 		waitInMilliseconds(250);
	 		turnLEDOff(LEDdebug);
	 		waitInMilliseconds(250);
	 	}
	 	return true;	//If it detects that the values go at -1 or more of boundaries, it will flash an error code and return true
	}else if((Xdistance+xypoints[0])<Xmax || (Ydistance+xypoints[1])<Ymax){
  	for (int i = 0; i <= 5; i++) {
	 		turnLEDOn(LEDdebug);
	 		waitInMilliseconds(250);
	 		turnLEDOff(LEDdebug);
	 		waitInMilliseconds(250);
	 	}
	 	return true;	//If it detects that the values go farther than XYmax, it will flash an error code and return true
	}else{return false;}
}




void move(float X,float Y){//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//moves the head to absolute position on the grid
	//outofbounds();
	//if(outofbounds() == true){return;}

	xypoints[0] = X;
	xypoints[1] = Y;

//outofbounds();
//if(outofbounds() == true){return;}
if(xypoints[0]==0){Xneg = 1;}else{Xneg = xypoints[0]/abs(xypoints[0]);}	//error correction for x or y =0 because you cant divide by 0
if(xypoints[1]==0){Yneg = 1;}else{Yneg = xypoints[1]/abs(xypoints[1]);}
//Xneg = xypoints[0]/abs(xypoints[0]);
//Yneg = xypoints[1]/abs(xypoints[1]);

if(abs(xypoints[0])>abs(xypoints[1])){
	Xspeed = Xneg;
	if(xypoints[1]==0){Yspeed=0;}else{Yspeed = (xypoints[1]/xypoints[0])*Xneg;}	//error correction for 0/0 error
	//Yspeed = (xypoints[0]/xypoints[1])*Xneg;//(xypoints[1]/xypoints[0]);
	slowtotaltime = slowmmTime*abs(xypoints[0]);
}else{
	Yspeed = Yneg;
	if(xypoints[0]==0){Xspeed=0;}else{Xspeed = (xypoints[0]/xypoints[1])*Xneg;}	//error correction for 0/0 error
	//Xspeed = (xypoints[0]/xypoints[1])*Xneg;
	slowtotaltime = slowmmTime*abs(xypoints[1]);
}

}




void drawLine(float X,float Y){//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//The first draw function!!!11!1111!
	//User will input "drawLine({XPoint,YPoint})"  i.e. drawLine({15,25})
/*

xypoints(3,5);
|      *
|     /|
|    /
|   /  | 5
|  /
| /    |
|/_______
	3
*/

//ERROR DETECTION needed


	xypoints[0] = X;
	xypoints[1] = Y;

//Currently Not in use, Broken
//outofbounds();
//if(outofbounds() == true){return;}

//Should the Motors move backwards or Forwards?
if(xypoints[0]==0){Xneg = 1;}else{Xneg = xypoints[0]/abs(xypoints[0]);}	//error correction for x or y =0 because you cant divide by 0
if(xypoints[1]==0){Yneg = 1;}else{Yneg = xypoints[1]/abs(xypoints[1]);}


//What % speed should the motors be going?
//Remember, If its xypoints{3,2} then X is moving at 100% and Y is moving at (2/3)%
if(abs(xypoints[0])>abs(xypoints[1])){
	Xspeed = Xneg;
	if(xypoints[1]==0){Yspeed=0;}else{Yspeed = (xypoints[1]/xypoints[0])*Xneg;}	//error correction for 0/0 error
	slowtotaltime = slowmmTime*abs(xypoints[0]);
}else{
	Yspeed = Yneg;
	if(xypoints[0]==0){Xspeed=0;}else{Xspeed = (xypoints[0]/xypoints[1])*Xneg;}	//error correction for 0/0 error
	slowtotaltime = slowmmTime*abs(xypoints[1]);
}

//DRAWING ITTTTTTTTTTTTTTTTTTT

//The final speed that the XY motors will move at
XrealSpeed = Xspeed*slowMotorSpeed;//EDIT its because you cant have floats in startMotor	//For some reason I have to make the math outside of the start motor movements for negetives
YrealSpeed = Yspeed*slowMotorSpeed;
//cheese = Xspeed*slowMotorSpeed;	//Debug, or is it???????

pen(false);	//Moves pen down
clearTimer(T1);	//Clear watchdog timer

//This will loop until time T1 equals the total time it should be going at
while(time1[T1] < slowtotaltime){
	//cheese = Xspeed*slowMotorSpeed;	// ._.

	startMotor(MotorX,XrealSpeed);
	startMotor(MotorY,YrealSpeed);	//YOU CANT PUT IN A FLOAT NUMBER IN THE MOTOR SPEED AHHHHHHHHHHHHH
}

}




task main()
{
	startup();

/*
	//HI
	drawLine(0,5);

	drawLine(10,0);
	drawLine(-5,0);
	drawLine(0,5);
	drawLine(5,0);
	drawLine(-10,0);
	drawLine(0,12);

	drawLine(0,-2);
	drawLine(10,0);
	drawLine(0,2);
	drawLine(0,-8);
	drawLine(0,0);
*/

drawLine(15,20);
}
